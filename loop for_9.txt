forcheck.l

%option noyywrap

%{
#include <stdio.h>
#include "forcheck.tab.h"   /* tokens from bison; generated by `bison -d` */
%}

/* whitespace */
[ \t\r]+           { /* skip */ }

/* keywords */
"for"              { return FOR; }
"int"|"float"|"double"|"char" { return TYPE; }

/* identifiers and numbers */
[A-Za-z_][A-Za-z0-9_]*  { yylval.str = strdup(yytext); return ID; }
[0-9]+                  { yylval.str = strdup(yytext); return NUMBER; }

/* operators and punctuation */
"=="    { return EQ; }
"!="    { return NE; }
"<="    { return LE; }
">="    { return GE; }
"++"    { return INC; }
"--"    { return DEC; }
"="     { return ASSIGN; }
"+"     { return '+'; }
"-"     { return '-'; }
"*"     { return '*'; }
"/"     { return '/'; }
"<"     { return '<'; }
">"     { return '>'; }
","     { return ','; }
";"     { return ';'; }
"("     { return '('; }
")"     { return ')'; }
"{"     { return '{'; }
"}"     { return '}'; }

/* newline: help with error messages */
\n      { /* ignore but could track line numbers */ }

/* anything else */
.       { /* unknown character */ return yytext[0]; }



forcheck.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int yylex(void);
void yyerror(const char *s);

%}

/* semantic value: keep strings for IDs/NUMBER if needed */
%union {
    char *str;
}

/* Tokens */
%token <str> ID NUMBER
%token FOR TYPE
%token EQ NE LE GE INC DEC ASSIGN

%type <str> init_part decl init_declarator declarator_list expr_list expression statement compound_stmt

%start input

%%

/* top-level: allow multiple statements / input */
input:
      /* empty */
    | input statement
    ;

/* a statement: for-stmt or other simple statement (we accept other statements to allow test inputs) */
statement:
      for_stmt
    | simple_stmt
    | compound_stmt
    ;

/* validate for loop */
for_stmt:
      FOR '(' for_init ';' for_cond ';' for_iter ')' statement
      {
        printf("Valid for-loop syntax\n");
      }
    ;

/* for header parts (allow empty) */
for_init:
      /* empty */               { /* allowed */ }
    | declaration               { /* declaration form */ }
    | expr_list                 { /* expression(s) */ }
    ;

for_cond:
      /* empty */
    | expression
    ;

for_iter:
      /* empty */
    | expr_list
    ;

/* declaration: TYPE declarator_list ';' is allowed in general C but inside for-init the trailing ';' is handled by header */
/* Here we parse a simple declaration list like: int i = 0, j = 2 */
declaration:
      TYPE declarator_list
    ;

/* list of declarators separated by commas */
declarator_list:
      init_declarator
    | declarator_list ',' init_declarator
    ;

/* a single declarator: ID or ID = expression */
init_declarator:
      ID
    | ID ASSIGN expression
    ;

/* comma-separated expressions (e.g., i = 0, j++ ) */
expr_list:
      expression
    | expr_list ',' expression
    ;

/* A compact expression grammar sufficient for validation */
expression:
      primary                            /* ID or NUMBER */
    | expression '+' expression
    | expression '-' expression
    | expression '*' expression
    | expression '/' expression
    | expression EQ expression
    | expression NE expression
    | expression '<' expression
    | expression '>' expression
    | expression LE expression
    | expression GE expression
    | '-' expression %prec UMINUS
    | primary INC                         /* postfix ++ */
    | primary DEC                         /* postfix -- */
    ;

/* primary expressions */
primary:
      ID
    | NUMBER
    | '(' expression ')'
    ;

/* a simple statement (for testing) -- ends with semicolon */
simple_stmt:
      expr_list ';'   { /* treat expression list followed by semicolon as a simple statement */ }
    ;

/* compound statement { ... } with optional nested statements (keeps it simple) */
compound_stmt:
      '{' stmts '}'
    ;

stmts:
      /* empty */
    | stmts statement
    ;

%%

void yyerror(const char *s) {
    fprintf(stderr, "Syntax error: %s\n", s);
}

int main(void) {
    printf("Enter input (Ctrl+D to finish):\n");
    yyparse();
    return 0;
}


bison -d forcheck.y        # creates forcheck.tab.c and forcheck.tab.h
flex forcheck.l           # creates lex.yy.c
gcc lex.yy.c forcheck.tab.c -o forcheck

./forcheck


for (i = 0 i < 10; i++)   // missing ';' between init and cond
for (int = 0; i<10; i++)  // missing identifier after type
for (i = ; i < 10; i++)   // bad init expression


